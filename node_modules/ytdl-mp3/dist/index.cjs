"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Downloader: () => Downloader,
  FormatConverter: () => FormatConverter,
  SongTagsSearch: () => SongTagsSearch,
  YtdlMp3Error: () => YtdlMp3Error
});
module.exports = __toCommonJS(src_exports);

// src/Downloader.ts
var import_os = __toESM(require("os"), 1);
var import_path = __toESM(require("path"), 1);
var import_node_id3 = __toESM(require("node-id3"), 1);
var import_ytdl_core = __toESM(require("ytdl-core"), 1);

// src/FormatConverter.ts
var import_child_process = __toESM(require("child_process"), 1);
var import_fs2 = __toESM(require("fs"), 1);
var import_ffmpeg_static = __toESM(require("ffmpeg-static"), 1);

// src/utils.ts
var import_fs = __toESM(require("fs"), 1);
var import_readline = __toESM(require("readline"), 1);
function removeParenthesizedText(s) {
  return s.replace(/\s*[([].*?[)\]]\s*/g, "");
}
function isDirectory(dirPath) {
  return import_fs.default.existsSync(dirPath) && import_fs.default.lstatSync(dirPath).isDirectory();
}
function userInput(prompt, defaultInput) {
  return __async(this, null, function* () {
    const rl = import_readline.default.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    return new Promise((resolve, reject) => {
      rl.question(prompt, (response) => {
        rl.close();
        if (response) {
          resolve(response);
        } else {
          reject(new YtdlMp3Error("Invalid response: " + response));
        }
      });
      rl.write(defaultInput || "");
    });
  });
}
var YtdlMp3Error = class extends Error {
  constructor(message, options) {
    super(message, options);
    this.name = "YtdlMp3Error";
  }
};

// src/FormatConverter.ts
var FormatConverter = class {
  constructor() {
    if (!import_ffmpeg_static.default) {
      throw new YtdlMp3Error("Failed to resolve ffmpeg binary");
    }
    this.ffmpegBinary = import_ffmpeg_static.default;
  }
  videoToAudio(videoData, outputFile) {
    if (import_fs2.default.existsSync(outputFile)) {
      throw new YtdlMp3Error(`Output file already exists: ${outputFile}`);
    }
    import_child_process.default.execSync(`${this.ffmpegBinary} -loglevel 24 -i pipe:0 -vn -sn -c:a mp3 -ab 192k ${outputFile}`, {
      input: videoData
    });
  }
};

// src/SongTagsSearch.ts
var import_axios = __toESM(require("axios"), 1);
var SongTagsSearch = class {
  constructor(videoDetails) {
    this.searchTerm = removeParenthesizedText(videoDetails.title);
    this.url = new URL("https://itunes.apple.com/search?");
    this.url.searchParams.set("media", "music");
    this.url.searchParams.set("term", this.searchTerm);
  }
  search(verify = false) {
    return __async(this, null, function* () {
      console.log(`Attempting to query iTunes API with the following search term: ${this.searchTerm}`);
      const searchResults = yield this.fetchResults();
      const result = verify ? yield this.getVerifiedResult(searchResults) : searchResults[0];
      const artworkUrl = result.artworkUrl100.replace("100x100bb.jpg", "600x600bb.jpg");
      const albumArt = yield this.fetchAlbumArt(artworkUrl);
      return {
        title: result.trackName,
        artist: result.artistName,
        image: {
          mime: "image/png",
          type: {
            id: 3,
            name: "front cover"
          },
          description: "Album Art",
          imageBuffer: albumArt
        }
      };
    });
  }
  fetchResults() {
    return __async(this, null, function* () {
      const response = yield import_axios.default.get(this.url.href).catch((error) => {
        var _a;
        if ((_a = error.response) == null ? void 0 : _a.status) {
          throw new YtdlMp3Error(`Call to iTunes API returned status code ${error.response.status}`);
        }
        throw new YtdlMp3Error("Call to iTunes API failed and did not return a status");
      });
      if (response.data.resultCount === 0) {
        throw new YtdlMp3Error("Call to iTunes API did not return any results");
      }
      return response.data.results;
    });
  }
  getVerifiedResult(searchResults) {
    return __async(this, null, function* () {
      for (const result of searchResults) {
        console.log("The following tags were extracted from iTunes:");
        console.log("Title: " + result.trackName);
        console.log("Artist: " + result.artistName);
        const validResponses = ["Y", "YES", "N", "NO"];
        let userSelection = (yield userInput("Please verify (Y/N): ")).toUpperCase();
        while (!validResponses.includes(userSelection)) {
          console.error("Invalid selection, try again!");
          userSelection = (yield userInput("Please verify (Y/N): ")).toUpperCase();
        }
        if (userSelection === "Y" || userSelection === "YES") {
          return result;
        }
      }
      throw new YtdlMp3Error("End of results");
    });
  }
  fetchAlbumArt(url) {
    return __async(this, null, function* () {
      return import_axios.default.get(url, { responseType: "arraybuffer" }).then((response) => Buffer.from(response.data, "binary")).catch(() => {
        throw new YtdlMp3Error("Failed to fetch album art from endpoint: " + url);
      });
    });
  }
};

// src/Downloader.ts
var _Downloader = class _Downloader {
  constructor({ outputDir, getTags, verifyTags }) {
    this.outputDir = outputDir != null ? outputDir : _Downloader.defaultDownloadsDir;
    this.getTags = Boolean(getTags);
    this.verifyTags = Boolean(verifyTags);
  }
  downloadSong(url) {
    return __async(this, null, function* () {
      if (!isDirectory(this.outputDir)) {
        throw new YtdlMp3Error(`Not a directory: ${this.outputDir}`);
      }
      const videoInfo = yield import_ytdl_core.default.getInfo(url).catch((error) => {
        throw new YtdlMp3Error(`Failed to fetch info for video with URL: ${url}`, {
          cause: error
        });
      });
      const formatConverter = new FormatConverter();
      const songTagsSearch = new SongTagsSearch(videoInfo.videoDetails);
      const outputFile = this.getOutputFile(videoInfo.videoDetails.title);
      const videoData = yield this.downloadVideo(videoInfo);
      formatConverter.videoToAudio(videoData, outputFile);
      if (this.getTags) {
        const songTags = yield songTagsSearch.search(this.verifyTags);
        import_node_id3.default.write(songTags, outputFile);
      }
      console.log(`Done! Output file: ${outputFile}`);
      return outputFile;
    });
  }
  /** Returns the content from the video as a buffer */
  downloadVideo(videoInfo) {
    return __async(this, null, function* () {
      const buffers = [];
      const stream = import_ytdl_core.default.downloadFromInfo(videoInfo, { quality: "highestaudio" });
      return new Promise((resolve, reject) => {
        stream.on("data", (chunk) => {
          buffers.push(chunk);
        });
        stream.on("end", () => {
          resolve(Buffer.concat(buffers));
        });
        stream.on("error", (err) => {
          reject(err);
        });
      });
    });
  }
  /** Returns the absolute path to the audio file to be downloaded */
  getOutputFile(videoTitle) {
    const baseFileName = removeParenthesizedText(videoTitle).replace(/[^a-z0-9]/gi, "_").split("_").filter((element) => element).join("_").toLowerCase();
    return import_path.default.join(this.outputDir, baseFileName + ".mp3");
  }
};
_Downloader.defaultDownloadsDir = import_path.default.join(import_os.default.homedir(), "Downloads");
var Downloader = _Downloader;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Downloader,
  FormatConverter,
  SongTagsSearch,
  YtdlMp3Error
});
//# sourceMappingURL=index.cjs.map