{"version":3,"sources":["../src/Downloader.ts","../src/FormatConverter.ts","../src/utils.ts","../src/SongTagsSearch.ts"],"sourcesContent":["import os from 'os';\nimport path from 'path';\n\nimport NodeID3 from 'node-id3';\nimport ytdl from 'ytdl-core';\nimport type { videoInfo as VideoInfo } from 'ytdl-core';\n\nimport { FormatConverter } from './FormatConverter';\nimport { SongTagsSearch } from './SongTagsSearch';\nimport { YtdlMp3Error, isDirectory, removeParenthesizedText } from './utils';\n\nexport interface DownloaderOptions {\n  outputDir?: string;\n  getTags?: boolean;\n  verifyTags?: boolean;\n}\n\nexport class Downloader {\n  static defaultDownloadsDir = path.join(os.homedir(), 'Downloads');\n\n  outputDir: string;\n  getTags: boolean;\n  verifyTags: boolean;\n\n  constructor({ outputDir, getTags, verifyTags }: DownloaderOptions) {\n    this.outputDir = outputDir ?? Downloader.defaultDownloadsDir;\n    this.getTags = Boolean(getTags);\n    this.verifyTags = Boolean(verifyTags);\n  }\n\n  async downloadSong(url: string): Promise<string> {\n    if (!isDirectory(this.outputDir)) {\n      throw new YtdlMp3Error(`Not a directory: ${this.outputDir}`);\n    }\n    const videoInfo = await ytdl.getInfo(url).catch((error) => {\n      throw new YtdlMp3Error(`Failed to fetch info for video with URL: ${url}`, {\n        cause: error,\n      });\n    });\n\n    const formatConverter = new FormatConverter();\n    const songTagsSearch = new SongTagsSearch(videoInfo.videoDetails);\n\n    const outputFile = this.getOutputFile(videoInfo.videoDetails.title);\n    const videoData = await this.downloadVideo(videoInfo);\n\n    formatConverter.videoToAudio(videoData, outputFile);\n    if (this.getTags) {\n      const songTags = await songTagsSearch.search(this.verifyTags);\n      NodeID3.write(songTags, outputFile);\n    }\n\n    console.log(`Done! Output file: ${outputFile}`);\n    return outputFile;\n  }\n\n  /** Returns the content from the video as a buffer */\n  private async downloadVideo(videoInfo: VideoInfo): Promise<Buffer> {\n    const buffers: Buffer[] = [];\n    const stream = ytdl.downloadFromInfo(videoInfo, { quality: 'highestaudio' }); // .pipe(fs.createWriteStream(outputFile));\n    return new Promise((resolve, reject) => {\n      stream.on('data', (chunk: Buffer) => {\n        buffers.push(chunk);\n      });\n      stream.on('end', () => {\n        resolve(Buffer.concat(buffers));\n      });\n      stream.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  /** Returns the absolute path to the audio file to be downloaded */\n  private getOutputFile(videoTitle: string): string {\n    const baseFileName = removeParenthesizedText(videoTitle)\n      .replace(/[^a-z0-9]/gi, '_')\n      .split('_')\n      .filter((element) => element)\n      .join('_')\n      .toLowerCase();\n    return path.join(this.outputDir, baseFileName + '.mp3');\n  }\n}\n","import cp from 'child_process';\nimport fs from 'fs';\n\nimport ffmpeg from 'ffmpeg-static';\n\nimport { YtdlMp3Error } from './utils';\n\nexport class FormatConverter {\n  private readonly ffmpegBinary: string;\n\n  constructor() {\n    if (!ffmpeg) {\n      throw new YtdlMp3Error('Failed to resolve ffmpeg binary');\n    }\n    this.ffmpegBinary = ffmpeg;\n  }\n\n  videoToAudio(videoData: Buffer, outputFile: string): void {\n    if (fs.existsSync(outputFile)) {\n      throw new YtdlMp3Error(`Output file already exists: ${outputFile}`);\n    }\n    cp.execSync(`${this.ffmpegBinary} -loglevel 24 -i pipe:0 -vn -sn -c:a mp3 -ab 192k ${outputFile}`, {\n      input: videoData,\n    });\n  }\n}\n","import fs from 'fs';\nimport readline from 'readline';\n\nexport function removeParenthesizedText(s: string): string {\n  return s.replace(/\\s*[([].*?[)\\]]\\s*/g, '');\n}\n\nexport function isDirectory(dirPath: string): boolean {\n  return fs.existsSync(dirPath) && fs.lstatSync(dirPath).isDirectory();\n}\n\nexport async function userInput(prompt: string, defaultInput?: string): Promise<string> {\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  return new Promise((resolve, reject) => {\n    rl.question(prompt, (response) => {\n      rl.close();\n      if (response) {\n        resolve(response);\n      } else {\n        reject(new YtdlMp3Error('Invalid response: ' + response));\n      }\n    });\n    rl.write(defaultInput || '');\n  });\n}\n\nexport class YtdlMp3Error extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(message, options);\n    this.name = 'YtdlMp3Error';\n  }\n}\n","import axios, { type AxiosError } from 'axios';\nimport type { MoreVideoDetails } from 'ytdl-core';\n\nimport { YtdlMp3Error, removeParenthesizedText, userInput } from './utils';\n\nexport interface SearchResult {\n  artistName: string;\n  trackName: string;\n  artworkUrl100: string;\n}\n\nexport interface SearchData {\n  resultCount: number;\n  results: SearchResult[];\n}\n\nexport interface AlbumArt {\n  mime: string;\n  type: {\n    id: number;\n    name: string;\n  };\n  description: string;\n  imageBuffer: Buffer;\n}\n\nexport interface SongTags {\n  title: string;\n  artist: string;\n  image: AlbumArt;\n}\n\nexport class SongTagsSearch {\n  private searchTerm: string;\n  private url: URL;\n\n  constructor(videoDetails: MoreVideoDetails) {\n    this.searchTerm = removeParenthesizedText(videoDetails.title);\n    this.url = new URL('https://itunes.apple.com/search?');\n    this.url.searchParams.set('media', 'music');\n    this.url.searchParams.set('term', this.searchTerm);\n  }\n\n  async search(verify = false): Promise<SongTags> {\n    console.log(`Attempting to query iTunes API with the following search term: ${this.searchTerm}`);\n    const searchResults = await this.fetchResults();\n    const result = verify ? await this.getVerifiedResult(searchResults) : searchResults[0];\n    const artworkUrl = result.artworkUrl100.replace('100x100bb.jpg', '600x600bb.jpg');\n    const albumArt = await this.fetchAlbumArt(artworkUrl);\n    return {\n      title: result.trackName,\n      artist: result.artistName,\n      image: {\n        mime: 'image/png',\n        type: {\n          id: 3,\n          name: 'front cover',\n        },\n        description: 'Album Art',\n        imageBuffer: albumArt,\n      },\n    };\n  }\n\n  private async fetchResults(): Promise<SearchResult[]> {\n    const response = await axios.get<SearchData>(this.url.href).catch((error: AxiosError) => {\n      if (error.response?.status) {\n        throw new YtdlMp3Error(`Call to iTunes API returned status code ${error.response.status}`);\n      }\n      throw new YtdlMp3Error('Call to iTunes API failed and did not return a status');\n    });\n\n    if (response.data.resultCount === 0) {\n      throw new YtdlMp3Error('Call to iTunes API did not return any results');\n    }\n\n    return response.data.results;\n  }\n\n  private async getVerifiedResult(searchResults: SearchResult[]): Promise<SearchResult> {\n    for (const result of searchResults) {\n      console.log('The following tags were extracted from iTunes:');\n      console.log('Title: ' + result.trackName);\n      console.log('Artist: ' + result.artistName);\n\n      const validResponses = ['Y', 'YES', 'N', 'NO'];\n      let userSelection = (await userInput('Please verify (Y/N): ')).toUpperCase();\n      while (!validResponses.includes(userSelection)) {\n        console.error('Invalid selection, try again!');\n        userSelection = (await userInput('Please verify (Y/N): ')).toUpperCase();\n      }\n      if (userSelection === 'Y' || userSelection === 'YES') {\n        return result;\n      }\n    }\n    throw new YtdlMp3Error('End of results');\n  }\n\n  private async fetchAlbumArt(url: string): Promise<Buffer> {\n    return axios\n      .get(url, { responseType: 'arraybuffer' })\n      .then((response) => Buffer.from(response.data as string, 'binary'))\n      .catch(() => {\n        throw new YtdlMp3Error('Failed to fetch album art from endpoint: ' + url);\n      });\n  }\n}\n"],"mappings":"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","names":["fs","fs"]}